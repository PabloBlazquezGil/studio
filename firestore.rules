/**
 * Core Philosophy: This ruleset enforces a "Public Read, Admin Write" security model.
 * All portfolio content, such as projects, client logos, and author details, is
 * publicly accessible to any user, including unauthenticated visitors. All write
 * operations (creating, updating, or deleting content) are strictly reserved for
 * authenticated users who are designated as administrators.
 *
 * Data Structure: The data is organized into flat, top-level collections. There are
 * three primary content collections (/projects, /client_logos, /author) and one
 * authorization collection (/roles_admin). There are no user-specific subcollections.
 *
 * Key Security Decisions:
 * - Public Content: The /projects, /client_logos, and /author collections are
 *   globally readable to support the public-facing portfolio website.
 * - Admin-Only Writes: Write access to all content is controlled by a single
 *   `isAdmin()` check. This simplifies security logic and centralizes administration.
 * - Role-Based Authorization: A user is considered an administrator if a document
 *   with their UID exists in the `/roles_admin` collection. This "existence over
 *   content" check is efficient and secure.
 * - Admin Collection Security: The `/roles_admin` collection itself is locked down.
 *   It cannot be read by non-admins, preventing enumeration of administrators. Only
 *   existing admins can manage the list of other admins.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    
    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }
    
    /**
     * Checks if the user's UID matches the document ID they are accessing.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the requesting user has an admin role.
     * This is determined by the existence of a document in the /roles_admin
     * collection where the document ID is the user's UID.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * @description Rules for the 'projects' collection. All project data is
     *   publicly readable by anyone. Only administrators can create, modify, or
     *   delete projects.
     * @path /projects/{projectId}
     * @allow (get) Any user, signed in or not, can read a specific project.
     * @allow (create) An admin user (auth.uid exists in /roles_admin) can add a new project.
     * @deny (update) A non-admin user cannot modify an existing project.
     * @principle Implements a "Public Read, Admin Write" model for global content.
     */
    match /projects/{projectId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
    
    /**
     * @description Rules for the 'client_logos' collection. All client logos are
     *   publicly readable. Only administrators can manage the logo entries.
     * @path /client_logos/{clientLogoId}
     * @allow (list) Any user, signed in or not, can list all client logos.
     * @allow (create) An admin user can add a new client logo.
     * @deny (delete) A regular signed-in user cannot delete a client logo.
     * @principle Implements a "Public Read, Admin Write" model for global content.
     */
    match /client_logos/{clientLogoId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
    
    /**
     * @description Rules for the 'author' collection. The author's information is
     *   publicly readable. Only administrators can modify this information.
     * @path /author/{authorId}
     * @allow (get) An anonymous visitor can read the author's bio.
     * @allow (update) An admin user can update the author's details.
     * @deny (create) A non-admin user cannot create a new author entry.
     * @principle Implements a "Public Read, Admin Write" model for singleton global content.
     */
    match /author/{authorId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for 'site_settings'. Global settings are
     *   publicly readable. Only administrators can modify them.
     * @path /site_settings/{settingsId}
     * @principle Implements a "Public Read, Admin Write" model for singleton global content.
     */
    match /site_settings/{settingsId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
    
    /**
     * @description Rules for the 'roles_admin' collection. This collection manages
     *   who has administrative privileges across the application. It is not publicly
     *   readable to prevent user enumeration. Only existing admins can manage roles.
     * @path /roles_admin/{uid}
     * @allow (create) An existing admin can grant admin rights to another user by creating a document with that user's UID.
     * @allow (get) An admin can check for the existence of their own role document.
     * @deny (list) A non-admin user cannot list who the admins are.
     * @deny (delete) A non-admin cannot revoke their own or anyone else's admin rights.
     * @principle Secures the role management system itself, allowing admins to manage other admins.
     */
    match /roles_admin/{uid} {
      allow get: if isOwner(uid);
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}
